Para la creación de los procesos no nos complicamos mucho, simplemente era hacer una "escalera" de procesos. Mediante un loop un proceso creaba a otro proceso y se salía, el hijo de este se quedaba en el loop hasta crear otro proceso y asi sucesivamente hasta llegar al número deseado de procesos.

Siguiendo el manual signal-safety tratamos de implementar los manejadores de forma que estos fuesen lo más cortos y seguros posibles, para evitar que el sistema no quede en un estado inconsciente. La acción de cada señal se ejecuta en el código principal, no en el manejador en sí, en este únicamente tenemos una variable global para que cuando entre al manejador sea modificada y cuando salga de este, se pueda comprobar si ha sido modificada o no, en dicho caso se reestablecería el valor de la variable.
En cuanto a como el padre se comunica con su hijo, lo que hicimos fue que al crear los procesos, el padre antes de salir del loop guardase el PID de su hijo. Con este esquema tendríamos que todos los procesos guardan un PID exceptuando el último, que no tiene hijo. Como el último proceso no tiene hijo, guardamos antes del loop el PID del primer proceso y así el último proceso envia la señal correspondiente al primer proceso. Esto se ve reflejado en send_signal, una función que creamos para simplificar código.

Lo primero que hicimos fue otro manejador, la estructura de este es igual a la de SIGUSR1 (se modifica una variable global). Después mediante mascaras, hicimos que el proceso hijo solo pudiese recibir SITERM y SIGUSR1, y el padre solo podía recibir SIGUSR1 y SIGINT. 
En cuanto el primer proceso recibe la señal SIGINT, este envía una señal SIGTERM a su hijo, iniciandose así una cadena hasta llegar al último proceso, en este momento el último proceso termina su ejecución liberando los recursos utilizados, después su padre termina su ejecución, esto se hace gracias a un wait especifico para que los procesos esperen a su hijo. De esta forma el primer proceso solo se termina su ejecución cuando todos los demas han terminado su ejecución.

Aquí lo que hicimos fue una máscara que bloquease todas las señales posibles para después ejecutar sigsuspend con otras máscaras. De esta forma, el hijo por ejemplo mientras se ejecuta tendría todas las señales bloqueadas en una cola, pero en cuanto llegase a sigsuspend se desbloquearían las señales que la máscara usada en sigsuspend tiene libres (SIGUSR1 y SIGTERM). Así evitamos que el programa entre en un estado de espera del que no puede salir porque la señal puede llegar antes de iniciar la espera.

Para esto establecimos otro nuevo manejador para la señal SIGALRM que en cuanto pasan 10 segundos comienza la cadena de SIGTERM's.

No se ejecutan en el orden que corresponde. Es posible que la ejecución salga en orden pero no tenemos garantías de esto ya que esto depende del manejador.
Sí ahora los mensajes están ordenados independientemente del manejador. Esto es debido a que al hacer sleep damos tiempo a que si o si, el proceso que envía una señal, se suspenda esperando otra señal, antes de que su hijo envíe una señal.

Para sincronizar los procesos con semáforos decidimos crear 2 semáforos binarios, uno específico para los prints y otro para coordinar los ciclos. El primer semáforo es muy simple, simplemente cuando un proceso quiere escribir este hace wait, al terminar de escribir este hace post. El segundo semáforo coordina el ciclo, esto lo hacemos haciendo que el primer proceso no envíe ninguna señal hasta que el último proceso se lo permita.